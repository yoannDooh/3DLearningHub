# Présentation du projet
Ce projet a pour vocation d'être un terrain de jeu dans mon apprentissage du rendu 3D en temps réel avec Opengl sur le long-terme. Je souhaite lui donner une structure logique et qui permettra une mise à echelle simple dans le temps. Il est encore très loin de ce que je désirais, des fonctionnalités sont mal implémentés comme le calcul de la postion du soleil, et donc de la lumière directionelle principal et unique du rendu, par exemple. A l'avenir j'ai pour ambition, qu'il puisse génerer procédurallement des "biomes" avecs des environnements différents, qu'il construira selon certains patternes. 

# Structure du projet
## Dépendences
Ce projet a pour vocation à me sevir de terrain de jeu dans mon apprentissage du rendu 3D en temps réel avec Opengl sur le long-terme. J'ai souhaité lui crée une structure logique et qui permettra une mise à echelle simple dans le temps. Il est encore très loin de ce que je désirais, des fonctionnalités sont mal implémentés comme le calcul de la postion du soleil, et donc de la lumière directionelle principal et unique du rendu, par exemple. A l'avenir j'ai pour ambition, qu'il puisse génerer procédurallement des "biomes" avecs des environnements différents, qu'il construira selon certains patternes. 

## Mesh module
Le projet est organisé en 5 différents modules : Motion/Shader/Window et enfin Mesh.
Le module Mesh s'occupe de l'implémentation de toute ce qui est relié à la création d'attributs des points à envoyés lors du "drawCall. Elle n'est composé presque qu'exclusivement de classes de figures géométrique. 
C'est-à-dire que si l'on prend par exemple, la classe Icosahedron, dans l'implémentation de son constructeur est réalisé tout le calcul de la position des points pour constuire une sphère. Ici, j'ai choisis comme méthode pour construire une sphère celle de l'icosaèdre, c'est-à-dire que l'on construit via  cette formule mathématique : ![image](https://github.com/yoannDooh/3DLearningHub/assets/103749193/5e0ddde3-ac6f-4f6d-be5e-7c0ac857efae) la position des points de l'icosaèdre puis l'on construit ses 12 points, chacun a un indice que j'ai choisis de manière arbitraire, les voicis : ![image](https://github.com/yoannDooh/3DLearningHub/assets/103749193/7bfcb477-cb49-478d-af81-8c5ea8f757e8). Une fois la position des points et leur indices générer, je fais appelle à une fonction membre de la classe nommé setupIcosahedron, qui va génerer ce que l'on appelle le VAO, VBO et VBO, le VAO sers d'ID qu'on appelera au moment du drawCall de l'objet, il permetra de faire la conenction avec le VBO et l'EBO crée, qui respectivement contiennent les données des attributs des points/vertices, le second leurs indices. Une fois cela fait l'object est prêt il n'y a plus qu'à appeller sa fonction draw() pour le dessiner sur ce qu'on appelle le frameBuffer relié actuellement, un frameBuffer étant en quelque sorte la toile sur laquelle on dessine. La classe icoshaedron n'est qu'un exemple d'une des formes géométriques que je crée dans ce fichier, mais toutes les classes suivent la même structures où l'on créer en premier lieux les différents attributs voulu, dans ce cas-ci il n'y avait que les coordonées puisque le calcul des nomrals et UV(coordonées de textures) sont laissé au shader, puisque c'est dans celui via un processus de subdivision des triangles nommées tessellation que l'on créera la sphère, mais dans d'autre cas celle que ma classe Cube il y beaucoup plus de propriété. Cette classe calcule, coordonées des points ,UV, leur couleur leur étant associé pour pouvoir avoir cette représenation des couleurs RGB : ![image](https://github.com/yoannDooh/3DLearningHub/assets/103749193/6e9988d4-2485-4c24-8f26-12db2e68b36e), et il calcule également les normals des points. Enfin, après avoir calculer toutes les attributés respectifs des points chaque classe va crée un VAO,EBO,VBO pour les futures drawCalls. C'est à peu près tout ce qu'il faut savoir exhaustivement de cette classe. 
Une dernière partie interressante à détailler est la classe Terrain, elle fonctionne comme-ceci, on créer un terrain à l'aide d'une heightMap, une texture comme celle-ci : ![image](https://github.com/yoannDooh/3DLearningHub/assets/103749193/78fca131-43c2-45bb-a51e-944e47ead610) où les zones blances représente l'élelation du terain tandis que les zones noirs sont plates. On va appliquer cette texture sur une grande grid et c'est le travail de cette classe de générer attributs et indices pour cette grid où voici la construction des indices : ![image](https://github.com/yoannDooh/3DLearningHub/assets/103749193/f66781ac-35f9-42b2-87fc-06a5a09016f6) , le nombre de carrée  crée est décidé par le paramètre PatchNb. Chaque terrain a un ID, et on peut alors crée un assemblage de terrain pour créer de très grande map. Chaque nouveau terrain peut être ajouté au nord/sud/est/ouest de celui désiré. Chaque terrain est composé de zones = "areas", qui ont chacunes leur textures uniques, s'étendants sur la région désirées du terrain que l'on précise sur x et y, via le système d'unité du monde où, 10 unités correspondent à un 1mètres dans notre réalité. On peut alors combiner plusieurs zones de textures différents sur un seul terrain.   



## Window Module
Ce module est assez simple, il s'occupe de tout ce qui est relié à la création de la fenêtre dans l'environnement GLFW, et donc également à tout ce qui reliés aux inputs de l'utilisateur. Il comporte par exemple les fonctions Call_Backs qui sont appellés lors de l'input auquel ils sont reliés. Par exemple mouse_callback sera appellé à chaque mouvement de souris afin de calculer dans qu'elle direction la caméra, que l'on calcule via une matrice, va se tourner, on réaliser cela à l'aide des angleus d'euleur ![image](https://github.com/yoannDooh/3DLearningHub/assets/103749193/59dc80cf-aa54-411a-b428-4891560d4a6c)

## Shader Module
Ce module intègre tout ce qui est relié à l'envoi de donnée au shader. On y trouve l'implémentation de la class Shader, qui va prendre en arugment les diffénrents fichier textes des shaders et lire une à une les lignes et les debugger et afficher les messages d'erreurs. J'y ait rajouter de plus des fonctions gérant mes UBO et SSO (Uniform Buffer Object) (Shader Storage Object), des objets en Opengl permettant de réservez une zone mémoire dans le GPU, que l'on relie à un "binding point" afin de permettre aux cpu d'envoyer les données à un endroit, qui sera partager par l'ensembles des Shaders plutôt que de renvoyers à de multiples reprises les mêmes données à différentes shaders alors que le processus d'échange de donnée entre CPU et GPU est très coûteux en performance : ![image](https://github.com/yoannDooh/3DLearningHub/assets/103749193/e28bec1c-4fdd-467b-8511-445dfd43e943) . Un Ubo prend beaucoup moins de place en mémoire que le SSO, et n'a pas une mémoire dynamique contrairement à lui, je m'en sers donc pour y stocker ma matrice projection, de caméra et le vec3 contenant la position de ma caméra, tandis que j'ai 2 SSO pour mes 2 types de lumière : point de lumière, et lumière "spotlights" bien que le dernier ne soit pas présent dans le rendu acutelle. 
![image](https://github.com/yoannDooh/3DLearningHub/assets/103749193/92a2edd1-6e3c-44aa-aa87-6f101c2a7e82)


## Motion Module
Il ne porte pas très bien son nom en réalité ce module fait énormément de choses, mais pour le résumer, il s'occupe de toute les fonctions qui sont appelés dans la renderLoop où les fonctions qui positionne les objets. Il comporte de plus des nameSpace important où sont conserver divers variables globales, comme toute celle relié au calcul de temps, que cela soit le temps au-seins du "jeu" où 1minnutes dans notre rélation correspond à 1heur dans le "jeu" par défaut si l'on ne fait pas appel à la fonction permettant d'accelerer le temps. Où encore les variables suivant les fps, où temps écoulé depuis le début de l'éxecution du progamme, ou encore le namespace World qui comporte tous les objets du monde. Ses 3 variables les plus importantes sont le vecteur d'objetss, il sert à stocker tout les objets de la classe object du monde, et et la deuxième variable est un vecteur des points de lumière et lumière "spotlights". Le type de donnée Object converse de multiple donées important sur l'object, dont justement l'ID dans la variable vecteur de la lumière auquelle il est relié s'il y en une. Cela sera utile plus tard lorsqu'il y aura des objets tels qu'un lampadaire qui incorpore une source de lumière, ici dites "spotslights". Comme dit précedemment cette classe gère également toutes les fonctions éxecutés dans la renderLoop, comme par exemple celle permettant de calculer le changement de la lumière directionelle dans le temps où encore setLighting qui envoye toutes les données de lumière au UBO et SSO.  

# Shaders
Il y a beaucoup de Shader mais un des plus interessant est celui de la sphère, qui utilise donc la tessellation. Il est composé de 4 Shader : le vertex qui va simplement envoyer les données du GPU au shader suivant : le suivant étant le Tessellation Control Shader (TCS) qui va indiquer commment la subdivision des triangles doit être opérer via un controle sur les 3 côtés de "l'inners"(triangle à l'intérieur dutriangle) et "outer" les 3 côtés du triangle ![image](https://github.com/yoannDooh/3DLearningHub/assets/103749193/56d70f5b-2c95-4327-9320-bb0598de52c7)
Ensuite intervient le Tessellation evaluation Shader (TES) qui va s'occuper de gérer l'inteprolation des attributs des points génerer via subdivisions, et donc ici calculer UV et normal principalement de la sphère.
On pourrait aussi parler du shader hemisphere qui est très similaire mais incorpore un système de "layer" pour mettre des textures de nuages par dessus, et surtout un système de calcule de couleurs, des gradiants que l'on calcul par interpolation, et le couleurs choisis pour rééalisés les gradients sont eux-même interpolé selon l'heure de la journée, et la phase (dawn/daytime/sunset/night) auquelle il appartient 

